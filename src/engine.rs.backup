use crate::chess_board::{Color, PieceType, Square};
use crate::ChessBoard;
use crate::Move; // Use the Move struct from your existing chess module

/// A simple heuristic evaluation function.
/// Calculates the score of the current board state from the perspective of the active player.
fn evaluate_board(board: &ChessBoard) -> i32 {
    const PAWN_VALUE: i32 = 100;
    const KNIGHT_VALUE: i32 = 300;
    const BISHOP_VALUE: i32 = 300;
    const ROOK_VALUE: i32 = 500;
    const QUEEN_VALUE: i32 = 900;
    const KING_VALUE: i32 = 10000;

    let mut score = 0;

    for row in 0..8 {
        for col in 0..8 {
            if let Square::Occupied(piece) = board.squares[row][col] {
                let piece_value = match piece.kind {
                    PieceType::Pawn => PAWN_VALUE,
                    PieceType::Knight => KNIGHT_VALUE,
                    PieceType::Bishop => BISHOP_VALUE,
                    PieceType::Rook => ROOK_VALUE,
                    PieceType::Queen => QUEEN_VALUE,
                    PieceType::King => KING_VALUE,
                };

                match piece.color {
                    Color::White => score += piece_value,
                    Color::Black => score -= piece_value,
                }
            }
        }
    }

    score
}

/// Negamax implementation with alpha-beta pruning.
fn negamax(board: &mut ChessBoard, depth: i32, alpha: i32, beta: i32, node_count: &mut u64) -> i32 {
    *node_count += 1;
    if depth == 0 {
        // Base case: return heuristic score of the position
        return evaluate_board(board) * if board.active_color == Color::White { 1 } else { -1 };
    }

    let mut alpha = alpha;
    let mut best_value = alpha;

    let moves = board.generate_legal_moves();
    if moves.is_empty() {
        // Handle checkmate or stalemate
        if board.is_checkmate() {
            return -100000 - depth; // Large negative score for a loss
        } else if board.is_stalemate() {
            return 0; // Stalemate is a draw
        }
    }

    for mv in moves {
        let mut board_clone = board.clone();
        board_clone.make_move(mv);

        let value = -negamax(&mut board_clone, depth - 1, -beta, -alpha, node_count);
        best_value = best_value.max(value);
        alpha = alpha.max(best_value);

        if alpha >= beta {
            // Beta cutoff
            break;
        }
    }

    alpha
}

/// Find the best move using negamax and alpha-beta pruning.
pub fn find_best_move(board: &ChessBoard, depth: i32) -> Option<(Move, i32, u64)> {
    let mut best_move = None;
    let mut best_value = i32::MIN;
    let mut alpha = i32::MIN + 1;
    let beta = i32::MAX;

    let mut node_count = 0;

    let moves = board.generate_legal_moves();

    for mv in moves {
        let mut board_clone = board.clone();
        board_clone.make_move(mv);

        let value = -negamax(&mut board_clone, depth, -beta, -alpha, &mut node_count);
        //println!("Move: {} Score: {}", mv.as_algebraic(), value);
        if value > best_value {
            best_value = value;
            best_move = Some(mv);
        }

        alpha = alpha.max(best_value);
    }

    best_move.map(|mv| (mv, best_value, node_count))
}
